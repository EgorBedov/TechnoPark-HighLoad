# HW3 (HighLoad App Architecture)

## 1. Выбор темы
Мессенджер

## 2. Определение возможного диапазона нагрузок
* Ежесуточная аудитория 90млн человек ~ ВК
* Ежедневно пользователи отправляют 10млрд сообщений [[1]](https://iz.ru/872421/2019-04-25/chislo-ezhednevnykh-soobshchenii-vkontakte-vyroslo-do-10-mlrd)
* На каждое отправленное сообщение пользователь получает от 1 до 10 сообщений. Помимо этого пользователи загружают чаты при входе в приложение, что происходит несколько раз в день => в среднем на один POST запрос пользователь делает 5 GET запросов, которые могут быть в несколько раз больше отправленного сообщения.

## 3. Выбор планируемой нагрузки как 60% доля рынка России
Из предыдущего пункта делаем вывод, что ВК получает 10млрд * 5/(24 * 60 * 60) = **575к RPS**. Для нашей доли рынка снизим RPS на 40% и получим **345к RPS**

Примем вес одного POST запроса равным:

10 слов * 6 символов * 4 байта = 240 байт

Пример вес одного GET запроса равным в пять раз превышающим POST запрос = 1 кБ


Итоговая нагрузка:

( 240 байт * 345000 * 0.2 + 1кБ * 345000 * 0.8 ) * 8 бит = ( 16 560 000 + 282 624 000 ) * 8 бит = 2,4 Гб/с

## 4. Логическая схема базы данных (без выбора СУБД)
![db_scheme](images/db_scheme.png)

## 5. Физическая системы хранения (конкретные СУБД, шардинг, расчет нагрузки, обоснование реализуемости на основе результатов нагрузочного тестирования)
Для хранения данных я выбрал базу PostgreSQL из-за её сильных сторон:
1. Обширный функционал
2. Большое комьюнити
3. Долгое время на рынке = качество
4. Легко найти разработчиков

Таблица сообщения является основной и наиболее нагруженной. В ней необходимо построить индексы и настроить партицирование по дате, чтобы от увеличения количества сообщений в базе не падало время ответа.

## 6. Выбор прочих технологий
### Back-End
Бекенд для такого сервиса не обладает сложной логикой, однако должен быть максимально быстрым. Подходящие для этого языки: Go, C, C++, Java. Из них я бы выбрал Go, поскольку:
1. Он имеет большую скорость разработки
    1. Не нужно следить за утилизацией памяти (как в C/C++)
    2. Гораздо меньший boilerplate для того же функицонала по сравнению с Java
    3. Параллельность из коробки
2. Он достаточно долго был на рынке:
    1. Большой комьюнити
    2. Большой опыт
3. Он специально создавался как язык для бекенд серверов

### Front-End
Фронтенд для такого сервиса так же не отличается большим функционалом, однако должен правильно уметь правильно реагировать на частое обновления информации на странице. Поэтому для веб версии мы выберем классический набор языков: [HTML](https://ru.wikipedia.org/wiki/HTML), [CSS](https://ru.wikipedia.org/wiki/CSS), [JavaScript](https://ru.wikipedia.org/wiki/JavaScript). 
> JavaScript, а не TypeScript, так же для скорости разработки, поскольку в данном случае нет перемещений и обработки сложных структур данных, поэтому можем пожертвовать статической типизацией

Также я выберу фреймворк React. Причины:
1. Высокая скорость разработки
2. Реактивное программирование обеспечивает быстрый рендер при обновлении информации
3. Большой комьюнити

### Дополнительно
1. Связь между бекендом и фронтендом будет происходить по протоколу [HTTPS](https://ru.wikipedia.org/wiki/HTTPS). Данные передаются в формате [JSON](https://ru.wikipedia.org/wiki/JSON)
2. Система контроля версий - GitHub
3. Непрерывная интеграция - GitHub Actions
4. Автоматический деплой - Ansible (поскольку у нас будет много серверов выполняющих одну логику, удобнее будет использовать именно его)
5. Бекенд будет оформлен в виде нескольких микросервисов (чатов, авторизации, истории и поиска)

## 7. Расчет нагрузки и потребного оборудования
Рассчитаем средние объемы памяти занимаемые каждой таблицей.

> Веса типов в PostgreSQL:
> * bigint - 8 байт
> * timestamp with time zone - 8 байт
> * varchar(n) - 8 * n байт

| Название таблицы                                        | users  | chats   | messages        |
|---------------------------------------------------------|--------|---------|-----------------|
| Размер одной записи [байт]                              | 50 * 4 | 50 + 8  | 256 + 8 + 8 + 8 |
| Предположительное количество записей [млн]              | 54     | 54 * 20 | 54 * 20 * 1000  |
| Общий вес [ГБ]                                          | 10,8   | 62,64   | 302 400         |
| Общий вес после прироста количества пользователей на 5% | 11,34  | 65,77   | 317 520         |


**Таким образом**, при условии, что у пользователя в среднем 50 *уникальных* чатов, и в каждом из них в среднем по 1000 сообщений, получаем общий объём памяти = **300ТБ**.

### Подбор оборудования
Микросервисы чатов и авторизации должны быть максимально быстрыми, но не хранящими долговременно много информации:
* [CPU](https://www.citilink.ru/catalog/computers_and_notebooks/servers_and_net_equipments/server_cpu/381950/properties/): 14 ядер, 2,6-3,5ГГц
* [RAM](https://www.citilink.ru/catalog/computers_and_notebooks/servers_and_net_equipments/server_memories/994294/): 4GB, 2133MHz -> x4
* [SSD](https://www.citilink.ru/catalog/computers_and_notebooks/hdd/ssd_in/1078055/): 1,9TB -> x2

Микросервисы истории и поиска наоборот могут позволить себе меньшую производительность, однако большую вместительность:
* [CPU](https://www.citilink.ru/catalog/computers_and_notebooks/servers_and_net_equipments/server_cpu/1125580/properties/): 8 ядер, 2,1-3ГГц 
* [RAM](https://www.citilink.ru/catalog/computers_and_notebooks/servers_and_net_equipments/server_memories/994294/): 4GB, 2133MHz -> x4
* [SSD](https://www.citilink.ru/catalog/computers_and_notebooks/hdd/ssd_in/1179581/): 3,8TB -> x4
